#!/opt/bin/php -c/opt/php.ini
<?php

use hollodotme\FastCGI;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Process\Process;

error_reporting(E_ALL | E_STRICT);
require 'vendor/autoload.php';

$AWS_LAMBDA_RUNTIME_API = \getenv('AWS_LAMBDA_RUNTIME_API');

function start_server(): Process
{
    $process = Process::fromShellCommandline('/opt/sbin/php-fpm -c/opt/php.ini -F -R', null, null, null, null);
    $process->start(function (string $type, string $data): void {
        echo $data;
    });

    return $process;
}

class CGIRequest extends FastCGI\Requests\AbstractRequest
{
    /**
     * @var string
     */
    private $method;

    /**
     * @var string
     */
    private $invocationId;

    public function __construct(string $method, string $invocationId, string $scriptFilename, string $content)
    {
        parent::__construct($scriptFilename, $content);

        $this->method = $method;
        $this->invocationId = $invocationId;
    }

    public function getRequestMethod(): string
    {
        return $this->method;
    }

    public function getInvocationId(): string
    {
        return $this->invocationId;
    }
}

$process = start_server();
$process->waitUntil(function (string $type, string $output): bool {
    return -1 !== \strpos($output, 'ready to handle connections');
});

if (! $process->isRunning()) {
    echo 'PHP-FPM is NOT running';
    die(1);
}

$connection = new FastCGI\SocketConnections\NetworkSocket('127.0.0.1', 9000, 5000, 5000);
$client = new FastCGI\Client($connection);

$apiClient = new GuzzleHttp\Client([
    'timeout' => 0.05,
]);
$nextRequest = new GuzzleHttp\Psr7\Request(Request::METHOD_GET, "http://$AWS_LAMBDA_RUNTIME_API/2018-06-01/runtime/invocation/next");

$handler = \getenv('_HANDLER');
$filename = \getenv('LAMBDA_TASK_ROOT').DIRECTORY_SEPARATOR.\substr($handler, 0, \strrpos($handler, '.')).'.php';

$requests = [];

function purge_timed_out_requests(): void
{
    global $requests;
    $time = \time();

    foreach (\array_keys($requests) as $requestId) {
        if ($requests[$requestId][1] > $time) {
            unset($requests[$requestId]);
        }
    }
}

while (true) {
    if ($client->hasUnhandledResponses()) {
        $readyRequestIds = $client->getRequestIdsHavingResponse();

        # read all ready responses
        foreach ($readyRequestIds as $requestId) {
            $response = $client->readResponse($requestId, 100);
            /** @var CGIRequest $cgiRequest */
            $cgiRequest = $requests[$requestId][0];

            $statusHeader = $response->getHeader('Status');
            $body = \json_encode([
                'body' => $response->getBody(),
                'statusCode' => (int) preg_replace('/^(\d+).+$/', '$1', $statusHeader),
                'statusDescription' => $statusHeader,
                'headers' => $response->getHeaders(),
                'isBase64Encoded' => false,
            ]);

            $responseRequest = new GuzzleHttp\Psr7\Request(
                Request::METHOD_POST,
                "http://$AWS_LAMBDA_RUNTIME_API/2018-06-01/runtime/invocation/{$cgiRequest->getInvocationId()}/response",
                [
                    'Content-Type' => 'application/json',
                    'Content-Length' => \strlen($body),
                ],
                $body,
            );

            $apiClient->send($responseRequest);
        }
    }

    $process->getExitCode();
    $nextInvocation = $apiClient->sendAsync($nextRequest);
    try {
        /** @var \Psr\Http\Message\ResponseInterface $response */
        $response = $nextInvocation->wait();
    } catch (GuzzleHttp\Exception\RequestException $exception) {
        purge_timed_out_requests();
        continue;
    }

    $invocationId = $response->getHeader('lambda-runtime-aws-request-id')[0] ?? null;
    if (null === $invocationId) {
        continue;
    }

    $event = \json_decode((string)$response->getBody(), TRUE);
    if (! isset($event['httpMethod'])) {
        $body = \json_encode([
            'body' => 'Unknown event',
            'statusCode' => 500,
            'statusDescription' => '500 Internal Server Error',
            'headers' => [],
            'isBase64Encoded' => false,
        ]);

        $responseRequest = new GuzzleHttp\Psr7\Request(
            Request::METHOD_POST,
            "http://$AWS_LAMBDA_RUNTIME_API/2018-06-01/runtime/invocation/{$invocationId}/response",
            [
                'Content-Type' => 'application/json',
                'Content-Length' => \strlen($body),
            ],
            $body,
        );

        $apiClient->send($responseRequest);
        \usleep(10);
        continue;
    }

    $body = $event['body'] ?? '';
    if ($event['isBase64Encoded'] ?? false) {
        $body = \base64_decode($body);
    }

    $query = \http_build_query($event['multiValueQueryStringParameters'] ?? $event['queryStringParameters'] ?? []);
    $cgiRequest = new CGIRequest($event['httpMethod'], $invocationId, $filename, $body);
    $cgiRequest->setCustomVar('QUERY_STRING', $query);
    $cgiRequest->setCustomVar('HTTPS', 'on');

    $cgiRequest->setRequestUri('https://localhost' . $event['path'] . '?' . $query);
    foreach ($event['multiValueHeaders'] ?? $event['headers'] ?? [] as $name => $values) {
        if ('content-type' === \mb_strtolower($name)) {
            $cgiRequest->setContentType($values);
        } elseif ('content-length' !== \mb_strtolower($name)) {
            $cgiRequest->setCustomVar('HTTP_' . \str_replace('-', '_', \mb_strtoupper($name)), $values);
        }
    }

    $cgiRequest->setCustomVar('_X_AMZN_TRACE_ID', $response->getHeader('Lambda-Runtime-Trace-Id')[0]);

    $requestId = $client->sendAsyncRequest($cgiRequest);
    $requests[$requestId] = [$cgiRequest, \time() + 60];
}
